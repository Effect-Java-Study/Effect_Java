# Item 48 - 스트림 병렬화는 주의해서 사용하라

<hr>

## 스트림  파이프라인?

<hr>

스트림은 데이터의 필터링, 매핑, 정렬, 그룹핑 등의 중간 처리와 합계, 평균, 카운팅, 최댓값, 최솟값 등의 최종 파이프라인으로 해결한다.

여기서, 파이프라인은 컴퓨터 과학에서 한 데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조를 말한다.

스트림 파이프라인은 소스 스트림에서 시작해 종단 연산으로 끝나며, 그 사이에 하나 이상의 중간 연산이 있을 수 있다.
종단 연산은 마지막 중간 연산이 내놓은 스트림에 최후의 연산을 가한다.

간단하게 말하자면 이전 데이터 처리의 출력이 다음 단계의 입력으로 이어지는 것으로 볼 수 있다.

## 스트림 병렬화?

<hr>

병렬 스트림은 데이터 병렬성을 구현한 것이다.

- 멀티 코어의 수만큼 대용량 요소를 서브 요소들로 나누고, 각각의 서브 요소들을 분리된 스레드에서 병렬 처리시킨다.
- 병렬 스트림은 내부적으로 포크조인 프레임워크를 이용한다.

### 포크조인

포크 단계

- 데이터를 서브 데이터로 반복적으로 분리한다.
- 서브 데이터를 멀티 코어에서 병렬로 처리한다.

조인 단계

- 서브 결과를 결합해서 최종 결과를 만들어 낸다.

### 병렬 스트림의 예

```Java
MaleStudent maleStudent = totalList.Stream()
  .filter(s -> s.getSex() == Student.Sex.MALE)
  .collect(MaleStudent::new, MaleStudent::accumulate, MaleStudent::combine);
```

- MaleStudent 객체는 하나만 생성
- 남학생일 결루 accumulate()가 호출되어 MaleStudent 객체 내부에 계속 누적
- combine() 메소드는 전혀 호출되지 않음

```Java
//병렬 스트림으로 수정
MaleStudent maleStudent = totalList.parallelStream()
        .filter(s -> s.getSex() == Student.Sex.MALE)
        .collect(MaleStudent::new, MaleStudent::accumulate, MaleStudent::combine);
```

- 코어의 개수 만큼 전체 요소는 서브 요소로 나뉘어지고, 해당 개수 만큼 스레드가 생성된다.
- 각 스레드는 서브 요소를 수집해야하므로 4개의 MaleStudent 객체를 생성하기 위해 collect()의 첫번째 메소드 참조인 MaleStudent::new를 4번 실행시킨다.
- 각 스레드는 MaleStudent 객체에 남학생 요소를 수집하기 위해 collect()의 두번째 메소드 참조인 MaleStudent::accumulate를 매번 실행시킨다.
- 수집 완료된 MaleStudent는 (코어 개수 - 1) 번의 결합으로 최종 수집된 MaleStudent로 만들어 진다. 따라서 collect()의 세번째 메소드 참조인 MaleStudent::combine() 이 (코어 개수 -1)번 실행된다.


## 병렬화가 문제가 되는 경우

<hr>

### 스트림 병렬화가 문제가 되는 경우

1. 안전 실패

- 스트림을 잘못 병렬화하면 응답 불가, 성능 저하, 오동작등이 발생한다.
- 결과가 잘못되거나 오동작하는 경우를 안전 실패(safety failure)라고 한다.

```Java
//메르센 소수를 생성하는 코드 (메르센 소수 : 2의 n승 - 1로 표현되는 소수)
public static void main(String[] args) {
	primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
			.filter(mersenne -> mersenne.isProbablePrime(50))
			.limit(20)
			.forEach(System.out::println);
}

static Stream<BigInteger> primes() {
	return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}
```

    위 코드가 쿼드 코어 시스템에서 동작한다고 했을 때 메르센 소수를 찾는 과정에서 19번째까지 계산하고 마지막 20번째 메르센 소수를 찾는 과정에서
    3개의 코어가 한가해진다. 따라서 21, 22, 23번째 수를 찾는 작업이 병렬로 시작되는게 20번째 수를 찾는 과정이 끝난다고 해도 앞서 말한 연산은 끝나지 않을 것이다.
    각각 20번째 계산보다 2배, 4배, 8배의 시간이 더 필요할 것이기 때문이다.

프로그램이 이렇게 느려진 원인은 사실 어이없게도 스트림 라이브러리가 이 파이프라인을 병렬화하는 방법을 찾아내지 못했기 때문이다. 
환경이 아무리 좋더라도 데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.

limit을 다룰 때 cpu 코어가 남는다면 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정한다.

그런데 이 코드의 경우 새롭게 메르센 소수를 찾을 때마다 그 전 소수를 찾을 때마다 두 배정도 더 오래걸린다.

원소 하나를 계산하는 비용이 대략 그 이전까지의 원소 전부를 계산한 비용을 합친 것만큼 든다는 뜻이다.


    - Stream.iterate
    forEach
    - limit
    Stream에서 일정 개수만큼만 데이터를 가져와서 새로운 스트림을 생성하고 리턴하는 메서드

2. 실제 작업보다 병렬화에 드는 추가 비용이 더 클 때

- 파이프라인이 수행하는 작업의 비용 < 병렬화에 드는 추가 비용이라면 성능 향상은 기대하기 어렵다.
- 스트림 안의 원소 수와 원소당 수행되는 코드 줄 수가 최소 수십만은 되어야 성능 향상이 기대된다.

3. 한 스레드의 문제가 다른 스레드에게 전이되는 경우

- 병렬 스트림 파이프라인은 같은 스레드 풀을 사용하므로 잘못된 파이프라인 하나가 시스템의 다른 부분의 성능에까지 악영향을 줄 수 있다.
- 따라서 스트림 병렬화를 적용할 땐 변경 전후로 성능을 테스트하여 문제가 없는지, 성능 향상이 실제로 유의미하게 이루어지는지 확인해야 한다.

## 그럼 언제 사용해야 하는가?

<hr>

### 1. 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때

1) 데이터의 분할이 정확하고 쉽다.

- 일을 다수의 스레드에 분배하기 좋다.

2) 참조 지역성이 뛰어나다.

- 참조 지역성이 낮으면 캐시 실패 확률이 높아지고, 이에 따라 스레드가 낭비된다.
  - 따라서 참조 지역성은 다량의 데이터를 처리하는 벌크 연산을 병렬화할 때 아주 중요한 요소로 작용한다.
- 참조 지역성이 가장 뛰어난 자료구조는 기본 타입의 배열이다.


    - 참조지역성
    참조의 지역성이란 컴퓨터 프로그램이 일정 기간 동안 특정한 메모리 위치 집합에 접근하는 경향이 있는 현상을 뜻한다. 
    쉽게 말해 참조의 지역성은 주소가 서로 가까운 명령어에 접근하는 경향을 나타낸다. 

### 2. 종단 연산이 병렬화에 적합할 때

축소(파이프라인에서 만들어진 모든 원소를 합치는 작업) 연산이 가장 병렬화에 적합하다.

    Stream의 reduce 메서드 중 하나, 혹은 min, max, count, sum 같이 완성된 형태로 제공되는 메서드 중 하나
    anyMatch, allMatch, noneMatch처럼 조건에 맞으면 바로 반환되는 메서드

가변 축소(mutable reduction)를 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 않다.
컬렉션들을 합치는 부담이 크기 때문이다.

## 정리

<hr>

스트림을 잘못 병렬화하면 프로그램을 오동작하게 하거나 성능을 급격히 떨어뜨린다. 

병렬화하는 편이 낫다고 믿더라도, 수정 후의 코드가 여전히 정확한지 확인하고 운영 환경과 유사한 조건에서 수행해보며 성능지표를 유심히 관찰하자. 

그래서 계산도 정확하고 성능도 좋아졌음이 확실해졌을 때 오직 그럴 때만 병렬화 버전 코드를 운영 코드에 반영하자.