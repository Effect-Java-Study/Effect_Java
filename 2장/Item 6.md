# Item 6 - 불필요한 객체 생성을 피하라

똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많음. <br>
특히 불변 객체는 언제든 재사용할 수 있음.

## String에 대해서

<hr>

```JAVA
String str = new String("str");
```
위 코드는 실행될 때마다 String 인스턴스를 새로 만듦.
new 키워드는 이전에 동일한 값이 사용되었는지 여부에 상관없이 항상 새 인스턴스를 생성하도록 함.

```JAVA
String str = "str";
```
위 코드는 새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용함.

자바는 문자열을 직접 할당할 시 문자열 상수 풀 내부에 모든 값을 저장함.
<br> 문자열 상수 풀은 힙 내에 있는 작은 캐시임.


이 방식을 사용한다면 같은 가상 머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장됨.

## 정적 팩터리 메서드를 이용하여 불필요한 객체 생성 방지

<hr>

생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있게 됨.
<br>
ex) Boolean(String) 생성자 대신 Boolean.valueOf(String) 팩터리 메서드를 사용하는 것이 좋음.
(실제로 이 생성자는 자바 9에서 사용 자제 API로 지정됨)

생성자는 호출할 때마다 새로운 객체를 만들지만, 팩터리 메서드는 전혀 그렇지 않음.

불변 객체가 아닌 가변 객체라 해도 사용 중에 변경되지 않을 것임을 안다면 재사용할 수 있음.

## 객체 생성이 비싼 경우 캐싱을 통한 객체 생성을 방지

<hr>

비싼 객체란 말은 인스턴스를 생성하는데 드는 비용이 크다는 의미임. <br>
즉, 메모리, 디스크 사용량, 대역폭 등이 높을수록 생성 비용이 비싼 경우.

### 예시 (Pattern)

```JAVA
static boolean isRomanNumeral(String str) {
    return str.matches("^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

String.matches가 가장 쉽게 정규 표현식에 매치가 되는지 확인하는 방법이긴 하지만 성능이 중요한 상황에서 반복적으로 사용하기에 적절하지 않음.

<br>

그 이유는 내부적으로 Pattern 인스턴스를 만들어 사용하는데 Pattern 인스턴스는 입력받은 정규표현식의 유한 상태 머신을 만들기 때문에 생성 비용이 높음.<br>

이런 생성 비용이 높은 Pattern 인스턴스를 한 번 쓰고 버리는 구조로 만들어 곧바로 GC의 대상이 되게 만들고 있음.
즉, 비싼 객체라고 할 수 있다.

이런 문제를 개선하기 위해서는 Pattern 객체를 만들어 컴파일하고 재사용을 하는 것이 좋음.

```JAVA
public class RomanNumber {
    private static final Pattern ROMAN = Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeral(String str) {
        return ROMAN.matcher(str).matches();
    }
}
```

두 방법의 성능을 확인해본 결과 캐싱된 인스턴스를 사용하는 경우 약 6배 정도의 성능 향상이 이루어짐.

Pattern 인스턴스를 클래스 초기화(정적 초기화) 과정에서 직접 생성해 캐싱해두고, 나중에 이 인스턴스를 재사용하는 것임.

추가로, 개선 전에서는 존재조차 몰랐던 Pattern 인스턴스를 static final 필드로 끄집어내고 이름을 지어주어 코드의 의미가 훨씬 잘 드러남.

## 오토 박싱을 사용할 때

<hr>

오토 박싱은 기본 타입과 박싱 된 기본 타입을 자동으로 변환해주는 기술임.

하지만 이를 잘못 사용하게 되면 불필요한 메모리 할당과 재할당을 반복하여 성능이 느려질 수 있음.

```JAVA
void autoBoxing() {
    Long sum = 0L;
    for(long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
}
```
sum 변수를 long이 아닌 Long으로 선언해서 불필요한 Long 인스턴스가 long 타입인 i가 Long 타입인 sum에 더해질 때마다 만들어지게 됨.


```JAVA
void noneBoxing() {
    long sum = 0L;
    for(long i = 0; i < Integer.MAX_VALUE; i++) {
        sum += i;
    }
}
```
박싱 타입이 필요한 경우가 아니라면 기본 타입을 사용하고, 의도치 않은 오토 박싱이 숨어들지 않게 주의해야 함.

## 정리

<hr>

객체 생성은 비싸니 피해야 한다는 것으로 오해하면 안됨.

요즘의 JVM에서는 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일이 크게 부담되지 않음.

프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것이라면 일반적으로 권장되는 일임.

정말 아주 무거운 객체가 아닌 이상, 단순히 객체 생성을 피하고자 본인만의 객체 풀을 만들지 말것.

JVM의 GC는 상당히 잘 최적화 되어있어 가벼운 객체를 다룰 때는 본인이 만든 객체 풀보다 훨씬 빠름.