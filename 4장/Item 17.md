# 아이템 17. 변경 가능성을 최소화하라


### 불변 클래스 만드는 방법 
> 1. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다. 
> 2. 클래스를 확장할 수 없도록 한다. 
>    * 하위 클래스에서 객체의 상태를 변화하는 것을 막는다. 
> 3. 모든 필드를 final 로 선언한다. 
>    * 시스템이 강제하는 수단을 이용해 설꼐자의 의도를 명확히 드러낸다. 
> 4. 모든 필드를 private 으로 선언한다. 
>    * 필드가 참조하는 가변 객체를 직접 접근해 수정하는 일을 막아준다.
>    * public final 로만 선언해도 불변 객체가 되지만, 나중에 클래스 구현 방식이나 내부 표현을 바꾸고 싶을 때 문제 발생한다. 
> 5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. 
>    * 가변 객체를 참조하는 필드가 하나라도 있디마녀 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야한다. 
>    * 생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행하라.
>      * 방어적 복사란 객체의 주소를 복사하지 말고, 객체의 내부 값을 참조하여 복사한다. 
>      * 이렇게 복사한 복사본은 원본과 다른 객체를 참조하지만, 해당 객체 내부에 있는 객체들은 원본과 동일한 주소를 참조한다. 
---

<details><summary>얕은 복사, 방어적 복사, 깊은 복사</summary><div>

### 얕은 복사 
- 얕은 복사는 원 본 객체의 멤버 변수들의 값만을 복사하는 방식이므로, 원본 객체와 복사본 객체의 기본타입의 멤버 변수는 독립적이다. 
- 하지만, 참조 타입의 멤버 변수는 객체의 주소값을 복사하여 복사본이 원본과 같은 객체를 참조한다. 
- 복사본에서 객체 내부의 값을 변경하면 원본 객체도 영향을 받는다. 
  - 그럼 언제 사용하는게 좋을까?
    - 깊은 복사보다 속도가 빨라야 할 때
    - 특정 상황에서 내부 데이터나 상태를 공유해야할 때 
    - 어떤 객체에 일시적인 작업을 수행할 때
- ~~~Java
  
    class Person {
        String name;
        Address address;
    }
    
    class Address {
        String city;
        String street;
    }
  ~~~
  Person 객체를 얕은 복사한다면...
  - name 은 기본 타입으로 복사본 Person의 name 은 독립적인 값을 갖는다.
  - 복사본 Person 의 address 는 참조 타입이므로 원본의 address 동일한 객체를 참조한다. 
  - 복사본 Person 의 address 의 city or street 변경하면, 원본도 영향을 받는다.  

### 방어적 복사
- 복사본이 원본 주소를 그대로 참조하지 않지만, 복사본 객체 내부에 있는 객체들은 원본과 동일한 주소를 참조한다. 
- List 는 같은 주소를 참조하지 않지만, List 내 각 요소들은 원본과 동일한 주소를 참조한다. 
- 요소를 변경할 수 있다는 의미이다. 
  - 왜 사용할까?
    - 객체의 내부 상태를 외부에 직접 노출시키지 않고, 복사본을 제공하여 객체의 불변성을 유지할 때 주로 쓴다.
    - 

### 깊은 복사 
- 객체의 모든 내부 상태를 완전히 복사하여 새로운 객체를 만드는 방식이다. 
- 원본 객체 내부의 모든 객체들도 재귀적으로 복사한다. 
- 복사된 객체와 원본 객체는 서로 다른 객체를 참조하고, 하나의 객체를 수정하더라도 다른 객체에 영향을 미치치 않는다. 

</div></details>
<details><summary>불변 클래스</summary><div>

불변클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스이다. String, BigInteger, 박싱된 클래스들이다.  
불변 클래스는 가변 클래스보다 설계가 구현하고 사용하기 쉽고, 오류가 생길 여지도 적어 훨씬 안전하다. 
</div>
</details>