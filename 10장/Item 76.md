# Item 76 - 가능한 한 실패 원자적으로 만들라

<hr>

## 실패 원자성?

<hr>

호출된 메서드가 실패해도 해당 객체가 메서드 호출 전 상태를 유지하는 특성

만약 실패 원자성을 띄지 않는다면, 어떠한 상태를 가지는지 알기 힘들다.
Rollback을 위해 추가적인 작업이 필요하다.

## 1. 메서드를 불변 객체로 설계한다.

<hr>

불변 객체는 태생적으로 실패 원자적이다.

### [아이템 17](https://github.com/Effective-Java-Study-2023/Effective_Java/blob/main/4%EC%9E%A5/Item%2017.md)

## 2. 가변 객체는?

<hr>

매개변수의 유효성을 검사한다.

```Java
public Object pop() {
    if (size == 0) throw new EmptyStackException();
    
    Object result = elements[--size];
    element[size] = null;
    return result;
}
```

일반화하자면,

실패할만한 모든 코드를 객체가 바뀌기 전에 배치하는 것이라고 할 수 있다.

즉, 계산을 수행하보기 전에 인수의 유효성을 검사해볼 수 없을 때 앞서 방식에 덧붙여 쓸수 있는 방식이라고 생각하면 된다.

예를 들어 TreeMap은 원소들을 어떤 기준에 맞춰서 정렬한다.
이때 그 원소는 기준에 따라 비교할 수 있는 타입이어야 한다. 엉뚱한 타입이 들어오면 Tree를 변경하기 전에 ClassCastException을 던지게 될 것이다.

## 객체의 임시 복사본에서 작업을 한 이후 작업이 완료 되면 원래 객체와 교체하자.

<hr>

- 데이터를 임시 자료구조에 저장해 작업하는게 더 빠르다면 적용하기 좋은 방식이다.
- 예를들어 어떤 정렬 메서드에서는 정렬을 수행하기 전에 입력 리스트의 원소들을 배열로 옮겨 담는다.
- 배열을 사용하면 정렬 알고리즘의 반복문에서 원소들에 빠르게 접근가능하기 때문이다.
  - 이에 대한 이점은 성능도 있지만, 정렬에 실패해도 입력 리스트는 변하지 않는 효과를 덤으로 얻게 된다.

## 작업 도중 발생하는 실패를 가로채고 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법

<hr>

주로 (디스크 기반내) 내구성을 보장해야 하는 자료구조에 쓰이는데, 자주 쓰이지는 않는다.

## 위 방법을 쓰면 항상 원자성을 보장할 수 있는가?

<hr>

자바와 같은 멀티 스레드 환경의 경우 도기화 없이 같은 객체를 수정하는 경우
두 스레드가 동기화 없이 같은 객체를 동시에 수정하면 일관성이 깨질 확률이 높다.

따라서 이럴 경우에는 `ConcurrentModificationException`을 잡아도 해당 객체를 여전히 쓸 수 있다고 생각하면 안된다.

항상 실패 원자성을 갖게 하는 것이 권장되나, 실패 원자성을 갖기 위해 너무나 많은 복잡도와 비용이 추가된다면 할 필요는 없다.


## 결론

<hr>

메서드 명세에서 기술한 예외라면, 예외가 발생해도 발생하기 전의 객체와 동등한 상황이어야 한다.

그러나, 실패 원자성을 담보할 수 없다면 예외 이후 객체의 상황을 API 설명에 명시해야 한다.



